import * as React from 'react';
import { type Placement, type PlacementWithAuto, type UseFloatingMiddleware } from '../../lib/floating';
import type { HasRef, HTMLAttributesWithRootRef } from '../../types';
import { type PopperArrowProps } from '../PopperArrow/PopperArrow';
export interface PopperRenderContentProps {
    className: string;
}
export interface PopperCommonProps extends HTMLAttributesWithRootRef<HTMLDivElement>, HasRef<HTMLDivElement> {
    /**
     * По умолчанию компонент выберет наилучшее расположение сам. Но его можно задать извне с помощью этого свойства
     */
    placement?: PlacementWithAuto;
    /**
     * Отступ по вспомогательной оси
     */
    offsetSkidding?: number;
    /**
     * Отступ по главной оси
     */
    offsetDistance?: number;
    /**
     * Отображать ли стрелку, указывающую на якорный элемент
     */
    arrow?: boolean;
    /**
     * Высота стрелки. Складывается с `offsetDistance`, чтобы стрелка не залезала на якорный элемент.
     */
    arrowHeight?: number;
    /**
     * Безопасная зона вокруг стрелки, чтобы та не выходила за края контента.
     */
    arrowPadding?: number;
    /**
     * Стиль стрелки.
     */
    arrowClassName?: string;
    /**
     * Пользовательская SVG иконка.
     *
     * Требования:
     *
     * 1. Иконка по умолчанию должна быть направлена вверх (a.k.a `IconUp`).
     * 2. Чтобы избежать проблемы с пространством между стрелкой и контентом на некоторых экранах,
     *    растяните кривую по высоте на `1px` и увеличьте на этот размер `height` и `viewBox` SVG.
     *    (см. https://github.com/VKCOM/VKUI/pull/4496).
     * 3. Передайте высоту иконки в параметр `arrowHeight`. В значении высоты можно исключить хак с `1px` из п.2.
     * 4. Убедитесь, что компонент принимает все валидные для SVG параметры.
     * 5. Убедитесь, что SVG и её элементы наследует цвет через `fill="currentColor"`.
     */
    ArrowIcon?: PopperArrowProps['Icon'];
    /**
     * Выставлять ширину равной target элементу
     */
    sameWidth?: boolean;
    forcePortal?: boolean;
    /**
     * Кастомный root-элемент портала.
     * При передаче вместе с `forcePorta=true` игнорируется `portalRoot` и `disablePortal`
     * из контекста `AppRoot`.
     */
    portalRoot?: HTMLElement | React.RefObject<HTMLElement> | null;
    /**
     * Подписывается на изменение геометрии `targetRef`, чтобы пересчитать свою позицию.
     */
    autoUpdateOnTargetResize?: boolean;
    /**
     * Массив кастомных модификаторов для Popper (необходимо мемоизировать)
     */
    customMiddlewares?: UseFloatingMiddleware[];
    /**
     * При передаче содержимого в `children`, он будет обёрнут во внутренний контейнер.
     *
     * Если хочется управлять этим контейнером, то используйте данную функцию.
     *
     * > ⚠️ Параметр `children` будет проигнорирован.
     */
    renderContent?(props: PopperRenderContentProps): React.ReactNode;
    onPlacementChange?(data: {
        placement?: Placement;
    }): void;
    /**
     * Принудительно скрывает компонет если целевой элемент исчез
     */
    hideWhenReferenceHidden?: boolean;
}
export interface PopperProps extends PopperCommonProps {
    targetRef: React.RefObject<HTMLElement>;
}
/**
 * @see https://vkcom.github.io/VKUI/#/Popper
 */
export declare const Popper: ({ targetRef, children, getRef, placement: placementProp, onPlacementChange, arrow, arrowHeight, arrowPadding, arrowClassName, ArrowIcon, sameWidth, offsetDistance, offsetSkidding, forcePortal, portalRoot, autoUpdateOnTargetResize, style: styleProp, customMiddlewares, renderContent, getRootRef, hideWhenReferenceHidden, ...restProps }: PopperProps) => React.JSX.Element;
//# sourceMappingURL=Popper.d.ts.map
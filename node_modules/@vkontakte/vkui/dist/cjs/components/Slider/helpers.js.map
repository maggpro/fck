{"version":3,"sources":["../../../../src/components/Slider/helpers.ts"],"sourcesContent":["import * as React from 'react';\nimport { rescale } from '../../helpers/math';\nimport type { InternalDraggingType, InternalValueState } from './types';\n\nexport const toPercent = (v: number, min: number, max: number) => ((v - min) / (max - min)) * 100;\n\nexport const offsetToValue = (\n  startX: number,\n  width: number,\n  min: number,\n  max: number,\n  step?: number,\n) => {\n  return rescale(startX, [0, width], [min, max], { step });\n};\n\nconst restrictValueByMinMax = (value: number, min: number, max: number) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\n\nexport const updateInternalStateValue = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  min: number,\n  max: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n\n  switch (dragging) {\n    case 'start':\n      return nextValue > prevEndValue\n        ? [prevEndValue, prevEndValue]\n        : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case 'end':\n      return nextValue < prevStartValue\n        ? [prevStartValue, prevStartValue]\n        : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport const updateInternalStateValueByNativeChange = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  switch (dragging) {\n    case 'start':\n      return [nextValue, prevEndValue];\n    case 'end':\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport function isMultipleValues(value: InternalValueState): value is [number, number] {\n  return value[1] !== null;\n}\n\nexport const snapDirection = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  type: InternalDraggingType | null,\n) => {\n  if (type === 'start') {\n    return 'start';\n  }\n  if (type === 'end') {\n    return 'end';\n  }\n\n  const [startRaw, endRaw] = prevValue;\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  const FORCE_DIFF_VALUE = 0.1;\n  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? 'start' : 'end';\n};\n\nexport const getDraggingTypeByTargetDataset = <T extends (EventTarget & HTMLElement) | null>(\n  target: T,\n) => {\n  if (target) {\n    if (target.dataset.type === 'start') {\n      return 'start';\n    }\n    if (target.dataset.type === 'end') {\n      return 'end';\n    }\n  }\n  return null;\n};\n\nconst resetProps = {\n  'aria-label': undefined,\n  'aria-valuetext': undefined,\n  'aria-labelledby': undefined,\n};\n\nexport const extractSliderAriaAttributesFromRestProps = <T extends React.AriaAttributes>(\n  restProps: T,\n) => {\n  const ariaLabel = restProps['aria-label'];\n  const ariaValueText = restProps['aria-valuetext'];\n  const ariaLabelledBy = restProps['aria-labelledby'];\n  return { ...restProps, ...resetProps, ariaLabel, ariaValueText, ariaLabelledBy };\n};\n"],"names":["extractSliderAriaAttributesFromRestProps","getDraggingTypeByTargetDataset","isMultipleValues","offsetToValue","snapDirection","toPercent","updateInternalStateValue","updateInternalStateValueByNativeChange","v","min","max","startX","width","step","rescale","restrictValueByMinMax","value","prevValue","nextValue","dragging","prevStartValue","prevEndValue","type","startRaw","endRaw","FORCE_DIFF_VALUE","start","end","Math","abs","target","dataset","resetProps","undefined","restProps","ariaLabel","ariaValueText","ariaLabelledBy"],"mappings":"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"}
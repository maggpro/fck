{"version":3,"sources":["../../../../src/hooks/useDraggableWithDomApi/useDraggableWithDomApi.ts"],"sourcesContent":["import * as React from 'react';\nimport type { TouchEvent } from '../../components/Touch/Touch';\nimport { getBoundingClientRect, getNearestOverflowAncestor, getNodeScroll } from '../../lib/dom';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { createAutoScrollController, getAutoScrollingData } from './autoScroll';\nimport {\n  AUTO_SCROLL_START_DELAY,\n  DATA_DRAGGABLE_PLACEHOLDER_KEY,\n  ITEM_INITIAL_INDEX,\n} from './constants';\nimport type {\n  Direction,\n  DraggingItem,\n  PlaceholderItem,\n  SiblingItem,\n  UseDraggable,\n  UseDraggableProps,\n} from './types';\nimport {\n  getTargetIsOverOrUnderElData,\n  setDraggingItemShiftStyles,\n  setInitialDraggingItemStyles,\n  setInitialPlaceholderItemStyles,\n  setInitialSiblingItemStyles,\n  setSiblingItemsShiftStyles,\n  unsetInitialDraggingItemStyles,\n  unsetInitialPlaceholderItemStyles,\n  unsetInitialSiblingItemStyles,\n} from './utils';\n\nexport const useDraggableWithDomApi = <T extends HTMLElement>({\n  elRef: draggingElRef,\n  onDragFinish,\n}: UseDraggableProps<T>): UseDraggable => {\n  const [dragging, setDragging] = React.useState(false);\n  const lastClientYRef = React.useRef(0);\n  const lastDragShiftYRef = React.useRef(0);\n\n  const scrollElRef = React.useRef<Element | Window | null>(null);\n  const lastScrollTopRef = React.useRef<number>(0);\n  const scrollControllerRef = React.useRef<ReturnType<typeof createAutoScrollController> | null>(\n    null,\n  );\n  const initializeScrollRefs = (draggableEl: HTMLElement) => {\n    const node = getNearestOverflowAncestor(draggableEl);\n    if (node) {\n      scrollElRef.current = node;\n      lastScrollTopRef.current = getNodeScroll(node).scrollTop;\n      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);\n    }\n  };\n  const cleanupScrollRefs = () => {\n    lastScrollTopRef.current = 0;\n    scrollControllerRef.current?.stop();\n    scrollElRef.current = scrollControllerRef.current = null;\n  };\n\n  const lastDragDirectionRef = React.useRef<Direction | undefined>(undefined);\n  const toggleDragDirection = (prevShiftY: number, nextShiftY: number) => {\n    const shiftYDiff = prevShiftY - nextShiftY;\n    if (shiftYDiff < 0) {\n      return 'down';\n    }\n    if (shiftYDiff > 0) {\n      return 'up';\n    }\n    return lastDragDirectionRef.current;\n  };\n\n  const itemStartIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const itemEndIndexRef = React.useRef<number>(ITEM_INITIAL_INDEX);\n  const draggingItemRef = React.useRef<DraggingItem | null>(null);\n  const placeholderItemRef = React.useRef<PlaceholderItem | null>(null);\n  const siblingItemsRef = React.useRef<SiblingItem[]>([]);\n  const initializeItems = (draggingEl: HTMLElement) => {\n    const draggingElRect = getBoundingClientRect(draggingEl, true);\n    const { children } = draggingEl.parentElement || { children: [] };\n    Array.prototype.forEach.call(children, (el: HTMLElement, index) => {\n      if (el === draggingEl) {\n        itemStartIndexRef.current = itemEndIndexRef.current = index;\n        draggingItemRef.current = { index, el, draggingElRect };\n      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {\n        placeholderItemRef.current = { index, el, draggingElRect };\n      } else {\n        siblingItemsRef.current.push({ index, el, shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index, draggingElRect }); // prettier-ignore\n      }\n    });\n    if (placeholderItemRef.current) {\n      setInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      setInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(setInitialSiblingItemStyles); // 2. repaint\n  };\n  const cleanupItems = () => {\n    if (placeholderItemRef.current) {\n      unsetInitialPlaceholderItemStyles(placeholderItemRef.current); // 1. reflow\n    }\n    if (draggingItemRef.current) {\n      unsetInitialDraggingItemStyles(draggingItemRef.current); // 2. repaint\n    }\n    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles); // 2. repaint\n    siblingItemsRef.current = [];\n    placeholderItemRef.current = draggingItemRef.current = null;\n\n    const swappedItemIndexRange = { from: itemStartIndexRef.current, to: itemEndIndexRef.current };\n    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;\n    return swappedItemIndexRange;\n  };\n  const getShiftAndUnshiftItemsPreparedData = (\n    clientY: number,\n  ): [Array<[SiblingItem, Direction]>, Array<[SiblingItem, Direction]>] => {\n    const shiftItemEls: Array<[SiblingItem, Direction]> = [];\n    const unshiftItemEls: Array<[SiblingItem, Direction]> = [];\n    itemEndIndexRef.current = itemStartIndexRef.current;\n    siblingItemsRef.current.forEach((siblingItem) => {\n      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(\n        clientY,\n        getBoundingClientRect(siblingItem.el),\n      );\n      if (itemStartIndexRef.current < siblingItem.index) {\n        if (isOverEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current + 1;\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            shiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n        if (isUnderEl) {\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            unshiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n      } else if (itemStartIndexRef.current > siblingItem.index) {\n        if (isUnderEl) {\n          itemEndIndexRef.current = itemEndIndexRef.current - 1;\n          if (lastDragDirectionRef.current === 'up' && !siblingItem.shifted) {\n            siblingItem.shifted = true;\n            shiftItemEls.push([siblingItem, 'down']);\n          }\n        }\n        if (isOverEl) {\n          if (lastDragDirectionRef.current === 'down' && siblingItem.shifted) {\n            siblingItem.shifted = false;\n            unshiftItemEls.push([siblingItem, 'up']);\n          }\n        }\n      }\n    });\n    return [shiftItemEls, unshiftItemEls];\n  };\n  const setShiftAndUnshiftItemStyles = (\n    shiftItemEls: Array<[SiblingItem, Direction]>,\n    unshiftItemEls: Array<[SiblingItem, Direction]>,\n  ) => {\n    shiftItemEls.forEach(setSiblingItemsShiftStyles);\n    unshiftItemEls.forEach(setSiblingItemsShiftStyles);\n  };\n\n  const schedulingAutoScrollTimeoutIdRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n  const clearSchedulingAutoScrollTimeout = () => {\n    if (schedulingAutoScrollTimeoutIdRef.current) {\n      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);\n      schedulingAutoScrollTimeoutIdRef.current = null;\n    }\n  };\n  const tryAutoScroll = () => {\n    if (scrollControllerRef.current) {\n      scrollControllerRef.current.tryAutoScroll(() => {\n        return scrollElRef.current\n          ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current)\n          : {\n              shouldScrolling: false,\n              y: 0,\n            };\n      });\n    }\n  };\n  const schedulingAutoScroll = () => {\n    clearSchedulingAutoScrollTimeout();\n    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {\n      schedulingAutoScrollTimeoutIdRef.current = null;\n      tryAutoScroll();\n    }, AUTO_SCROLL_START_DELAY);\n  };\n\n  const onDragStart = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const onDragMove = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    const draggingEl = draggingElRef.current;\n\n    if (!draggingEl) {\n      return;\n    }\n\n    if (dragging) {\n      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);\n      lastDragShiftYRef.current = event.shiftY;\n      lastClientYRef.current = event.clientY;\n\n      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n      } else {\n        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(\n          lastClientYRef.current,\n        );\n        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);\n        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n        schedulingAutoScroll();\n      }\n    } else {\n      setDragging((prevDragging) => {\n        // На случай, если onDragMove успеет вызваться ещё раз до того, как `dragging` выставится в\n        // `true`\n        if (prevDragging) {\n          return prevDragging;\n        }\n        initializeScrollRefs(draggingEl);\n        initializeItems(draggingEl);\n        return true;\n      });\n    }\n  };\n\n  const onDragEnd = (event: TouchEvent) => {\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n\n    clearSchedulingAutoScrollTimeout();\n    cleanupScrollRefs();\n\n    lastClientYRef.current = lastDragShiftYRef.current = 0;\n    lastDragDirectionRef.current = undefined;\n\n    if (dragging) {\n      const swappedItemRange = cleanupItems();\n      if (onDragFinish) {\n        onDragFinish(swappedItemRange);\n      }\n      setDragging(false);\n    }\n  };\n\n  const handleScroll = React.useCallback(() => {\n    if (!draggingElRef.current || !scrollElRef.current) {\n      return;\n    }\n\n    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;\n    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);\n    const scrollDiff = lastScrollTopRef.current - nextScrollTop;\n    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;\n    lastScrollTopRef.current = nextScrollTop;\n\n    const [shiftItemEls, unshiftItemEls] =\n      getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);\n    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);\n  }, [draggingElRef]);\n\n  useIsomorphicLayoutEffect(\n    function recalculateOnScroll() {\n      const scrollEl = scrollElRef.current;\n      if (!dragging || !scrollEl) {\n        return;\n      }\n      scrollEl.addEventListener('scroll', handleScroll);\n      return () => {\n        if (scrollEl) {\n          scrollEl.removeEventListener('scroll', handleScroll);\n        }\n      };\n    },\n    [dragging, handleScroll],\n  );\n\n  useIsomorphicLayoutEffect(\n    () =>\n      function componentWillUnmount() {\n        if (placeholderItemRef.current) {\n          unsetInitialPlaceholderItemStyles(placeholderItemRef.current);\n        }\n      },\n    [],\n  );\n\n  return { dragging, onDragStart, onDragMove, onDragEnd };\n};\n"],"names":["useDraggableWithDomApi","elRef","draggingElRef","onDragFinish","React","useState","dragging","setDragging","lastClientYRef","useRef","lastDragShiftYRef","scrollElRef","lastScrollTopRef","scrollControllerRef","initializeScrollRefs","draggableEl","node","getNearestOverflowAncestor","current","getNodeScroll","scrollTop","createAutoScrollController","cleanupScrollRefs","stop","lastDragDirectionRef","undefined","toggleDragDirection","prevShiftY","nextShiftY","shiftYDiff","itemStartIndexRef","ITEM_INITIAL_INDEX","itemEndIndexRef","draggingItemRef","placeholderItemRef","siblingItemsRef","initializeItems","draggingEl","draggingElRect","getBoundingClientRect","children","parentElement","Array","prototype","forEach","call","el","index","getAttribute","DATA_DRAGGABLE_PLACEHOLDER_KEY","push","shifted","setInitialPlaceholderItemStyles","setInitialDraggingItemStyles","setInitialSiblingItemStyles","cleanupItems","unsetInitialPlaceholderItemStyles","unsetInitialDraggingItemStyles","unsetInitialSiblingItemStyles","swappedItemIndexRange","from","to","getShiftAndUnshiftItemsPreparedData","clientY","shiftItemEls","unshiftItemEls","siblingItem","getTargetIsOverOrUnderElData","isOverEl","isUnderEl","setShiftAndUnshiftItemStyles","setSiblingItemsShiftStyles","schedulingAutoScrollTimeoutIdRef","clearSchedulingAutoScrollTimeout","clearTimeout","tryAutoScroll","getAutoScrollingData","shouldScrolling","y","schedulingAutoScroll","setTimeout","AUTO_SCROLL_START_DELAY","onDragStart","event","originalEvent","stopPropagation","preventDefault","onDragMove","shiftY","isRunning","setDraggingItemShiftStyles","prevDragging","onDragEnd","swappedItemRange","handleScroll","useCallback","nextScrollTop","scrollDiff","clientYWithScrollOffset","useIsomorphicLayoutEffect","recalculateOnScroll","scrollEl","addEventListener","removeEventListener","componentWillUnmount"],"mappings":"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"}